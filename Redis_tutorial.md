# Redis_tutorial



## 缓存更新策略

操作缓存还是数据库时有三个问题需要考虑：

1. 删除缓存还是更新缓存？
   1. 更新缓存：每次更新数据库都要更新缓存，但是期间可能没有那么多查询这个数据的请求，所以无效的写操作会比较多；
   2. 删除缓存：更新数据库时让缓存失效，查询时再更新缓存；
2. 如何保证缓存与数据库的操作的同时成功或失败？
   1. 单体系统，将缓存与数据库操作放在一个事务中；
   2. 分布式系统，利用分布式事务；
3. 先操作缓存还是先操作数据库？
   1. 先删缓存，再操作数据库；
      1. <img src="./images/先删除缓存再操作数据库.png" alt="先删除缓存再操作数据库" style="zoom:20%;" />
   2. 先操作数据库，再删除缓存；
      1. <img src="./images/先操作数据库再删除缓存.png" alt="先操作数据库再删除缓存" style="zoom:30%;" />



更新数据库的这个操作时间会比较长，所以2这种情况发生的概率比较小。



## 缓存穿透

**什么是缓存穿透**？

​	指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远都不会生效，这些请求都会打到数据库。

**解决方法**

1. 缓存空对象
   1. 因为需要额外缓存空对象，并设置TTL，所以会有额外的内存消耗；
   2. 万一原本的失效的id出现了，存在数据库中了，可能会造成短期的不一致。

2. 布隆过滤器
   1. 在客户端和redis之间加一个布隆过滤器，不存在是真的不存在，存在是不一定存在。

## 缓存雪崩

**什么是缓存雪崩**？

是指在同一时间段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。

**为什么会同一时间过期？**

在热key预热的时候，会统一添加。

**解决方法**：

1. 给不同的key的TTL添加随机值；
2. 利用Redis集群提高服务的可用性；
3. 给缓存业务添加限流策略；
4. 给业务添加多级缓存。

## 缓存击穿

**什么是缓存击穿**？

被高并发访问并且缓存重建业务较为复杂的key突然失效了，无数的请求访问会瞬间给数据库带来巨大冲击。

<img src="./images/缓存击穿1.png" alt="缓存击穿1" style="zoom:25%;" />

**解决方法**：

互斥锁

<img src="./images/缓存击穿2.png" alt="缓存击穿2" style="zoom:25%;" />

逻辑过期

<img src="./images/缓存击穿3.png" alt="缓存击穿3" style="zoom:30%;" />



## 使用redis实现全局ID

如果使用数据库自增ID会存在以下两个问题：

1. id的规律性太明显；
2. 受单表数据量大限制；
3. 如果使用分库分表，在两张不同的表里会存在相同的ID；



所以全局ID需要满足以下三个特性：

1. 唯一性；
2. 递增性；
3. 安全性；



go int64有64位，可以分为以下三部分：

1. 符号位：1bit，永远为0；
2. 时间戳：31bit，以秒为单位，可以使用69年；
3. 序列号：32bit，秒内的计数器，支持每秒产生2^32个不同ID；



**总结**

**全局唯一ID生成策略**：

1. UUID
2. Redis自增
3. snowflake算法
4. 数据库自增

**Redis自增ID策略**：

1. 每天一个key，方便统计订单量；
2. ID构造是 时间戳+计数器
