# Redis_tutorial



## 缓存更新策略

操作缓存还是数据库时有三个问题需要考虑：

1. 删除缓存还是更新缓存？
   1. 更新缓存：每次更新数据库都要更新缓存，但是期间可能没有那么多查询这个数据的请求，所以无效的写操作会比较多；
   2. 删除缓存：更新数据库时让缓存失效，查询时再更新缓存；
2. 如何保证缓存与数据库的操作的同时成功或失败？
   1. 单体系统，将缓存与数据库操作放在一个事务中；
   2. 分布式系统，利用分布式事务；
3. 先操作缓存还是先操作数据库？
   1. 先删缓存，再操作数据库；
      1. <img src="./images/先删除缓存再操作数据库.png" alt="先删除缓存再操作数据库" style="zoom:30%;" />
   2. 先操作数据库，再删除缓存；
      1. <img src="./images/先操作数据库再删除缓存.png" alt="先操作数据库再删除缓存" style="zoom:50%;" />



更新数据库的这个操作时间会比较长，所以2这种情况发生的概率比较小。



## 缓存穿透

1. 什么是缓存穿透？

​	

## 缓存雪崩

## 缓存击穿



## 使用redis实现全局ID

如果使用数据库自增ID会存在以下两个问题：

1. id的规律性太明显；
2. 受单表数据量大限制；
3. 如果使用分库分表，在两张不同的表里会存在相同的ID；



所以全局ID需要满足以下三个特性：

1. 唯一性；
2. 递增性；
3. 安全性；



go int64有64位，可以分为以下三部分：

1. 符号位：1bit，永远为0；
2. 时间戳：31bit，以秒为单位，可以使用69年；
3. 序列号：32bit，秒内的计数器，支持每秒产生2^32个不同ID；



**总结**

**全局唯一ID生成策略**：

1. UUID
2. Redis自增
3. snowflake算法
4. 数据库自增

**Redis自增ID策略**：

1. 每天一个key，方便统计订单量；
2. ID构造是 时间戳+计数器
